#set ($defaultValueMap = {
    "char"      : "'\0",
	"byte"		: "(uint8_t) 0",
	"boolean"	: "true",
	"int8"      : "(int8_t) 0",
	"uint8"     : "(uint8_t) 0",
	"short"		: "(int16_t) 0",
	"int16"     : "(int16_t) 0",
	"uint16"    : "(uint16_t) 0",
	"int"		: "(int32_t) 0",
	"int32"     : "(int32_t) 0",
	"uint32"    : "(uint32_t) 0",
	"long"		: "(int64_t) 0",
	"int64"		: "(int64_t) 0",
	"uint64"	: "(uint64_t) 0",
	"float"		: "(float) 0.00",
	"double"	: "(double) 0.00"
})
#set ($typeSizeMap = {
    "char"      : "1",
	"byte"		: "1",
	"boolean"	: "1",
	"int8"      : "1",
	"uint8"     : "1",
	"short"		: "2",
	"int16"     : "2",
	"uint16"    : "2",
	"int"		: "4",
	"int32"     : "4",
	"uint32"    : "4",
	"long"		: "8",
	"int64"		: "8",
	"uint64"	: "8",
	"float"		: "4",
	"double"	: "8"
})
#set ($typeOfCpp = {
    "char"      : "char",
	"byte"		: "uint8_t",
	"boolean"	: "bool",
	"int8"      : "int8_t",
	"uint8"     : "uint8_t",
	"short"		: "int16_t",
	"int16"     : "int16_t",
	"uint16"    : "uint16_t",
	"int"		: "int32_t",
	"int32"     : "int32_t",
	"uint32"    : "uint32_t",
	"long"		: "int64_t",
	"int64"		: "int64_t",
	"uint64"	: "uint64_t",
	"float"		: "float",
	"double"	: "double"
})
#set ($dataTypeEnum = {
    "string"    : "dt_string",
	"byte"		: "dt_byte",
	"boolean"	: "dt_boolean",
	"int8"      : "dt_byte",
	"uint8"     : "dt_byte",
	"short"		: "dt_short",
	"int16"     : "dt_short",
	"uint16"    : "dt_short",
	"int"		: "dt_int",
	"int32"     : "dt_int",
	"uint32"    : "dt_int",
	"long"		: "dt_long",
	"int64"		: "dt_long",
	"uint64"	: "dt_long",
	"float"		: "dt_float",
	"double"	: "dt_double"
})
## 宏: 为field赋初值
#macro (initField $field)
    // initialize ${field.name}
    #if ($field.type.isBasic())## 基本类型
        #if ($field.type.hasArray())## 数组
            #if ($field.type.fixedLength)## 定长数组
    this->${field.name}.resize(${field.type.arraySize});
            #end
        #else## 单个基本类型变量
    this->$field.name = ${defaultValueMap[${field.type.name}]};
        #end
    #elseif ($field.type.isString())## 字符串类型
    this->${field.name}.resize(${field.type.arraySize});
        #if ($field.defaultValue)## 有预设定的初始值
    this->$field.name = ${field.defaultValue.value};
        #end
    #else## struct类型
        #if ($field.type.hasArray())## struct数组
            #if ($field.type.isFixedLength())## 定长数组
    for (int i = 0; i < ${field.type.arraySize}; ++i) {
        this->${field.name}.push_back(${field.type.typeName}::instance());
    }
            #end
        #elseif ($field.type.typeName == "Struct")
    this->${field.name} = ${field.type.typeName}::instance($field.type.len);
        #else
    this->${field.name} = ${field.type.typeName}::instance();
        #end
    #end
#end
##

///////////////////////////////////////////////////////////////
// struct ${structName}
#if ($struct.haveComments())
//
#foreach ($line in $struct.comments)
// ${line}
#end
#end
${struct.className}::${struct.className}(void) : Struct("${struct.className}")
{
#foreach ($field in $struct.fields)
#initField($field)

#end
}

size_t ${struct.className}::size(void)
{
    size_t __size = 0;

#foreach ($field in $struct.fields)
    #if ($field.type.isBasic())
        #if ($field.type.fixedLength)
    __size += ${typeSizeMap[${field.type.name}]} * ${field.type.arraySize};
        #else
    __size += ${typeSizeMap[${field.type.name}]} * this->${field.name}.size();
        #end
    #elseif ($field.type.isString())
    __size += ${field.type.arraySize};
    #else
        #if ($field.type.hasArray())
            #if ($field.type.array.fixed)
    for (int i = 0; i < ${field.type.arraySize}; ++i) {
        __size += this->${field.name}[i]->size();
    }
            #else
                #if ($field.type.array.identifier)
    this->${field.type.arraySize} = (#declareType($struct.getField($field.type.arraySize))) this->${field.name}.size();
                #end
    for (int i = 0; i < this->${field.name}.size(); ++i) {
        __size += this->${field.name}[i]->size();
    }
            #end
        #else
    if (this->${field.name} != NULL) {
        __size += this->${field.name}->size();
    }
        #end
    #end

#end
    return __size;
}

void ${struct.className}::write(structpp::StructEncoder &encoder)
{
#foreach ($field in $struct.fields)
    #if ($field.type.isBasic())## 基本数据类型
        #if ($field.type.hasArray())## 数组
    encoder.write_array(&this->${field.name}, "${field.type.prototype}", "${field.name}", $dataTypeEnum[${field.type.name}]);
        #else
            #if ($field.reference)
    this->${field.name} = (#declareType($field)) this->${field.reference.name}.size();
            #end
    encoder.write_basic(&this->${field.name}, "${field.type.prototype}", "${field.name}", $dataTypeEnum[${field.type.name}], dt_none, 0);
        #end
    #elseif ($field.type.isString())
    encoder.write_string(&this->${field.name}, "${field.type.prototype}", "${field.name}");
    #else
        #if ($field.type.hasArray())
    encoder.write_vector(&this->${field.name}, "${field.type.prototype}", "${field.name}");
        #else
    encoder.write_struct(this->${field.name}, "${field.type.prototype}", "${field.name}");
        #end
    #end

#end
}

${struct.className}::~${struct.className}()
{
#foreach ($field in $struct.fields)
    #if ($field.type.isStruct())## Struct
        #if ($field.type.hasArray())
    for (int i = 0; i < this->${field.name}.size(); ++i) {
        delete this->${field.name}[i];
    }
        #else
    delete this->${field.name};
        #end

    #end
#end
}
