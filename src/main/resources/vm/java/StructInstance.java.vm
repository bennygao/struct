/******************************************************************************
 * ${struct.className}.java
 * GENERATED BY StructCompiler, DON'T MODIFY MANULLY.
 * Generated Time: ${createTime}
 */
package ${package};

import java.io.*;

#set ($defaultValueMap = {
    "char"      : "'\0'",
	"byte"		: "(byte) 0",
	"boolean"	: "false",
	"short"		: "(short) 0",
	"int"		: "0",
	"long"		: "0L",
	"float"		: "0",
	"double"	: "0.00"
})
#set ($typeSizeMap = {
    "char"      : "1",
	"byte"		: "1",
	"boolean"	: "1",
	"short"		: "2",
	"int"		: "4",
	"long"		: "8",
	"float"		: "4",
	"double"	: "8"
})
##
## 宏: 生成field的类型
#macro (declareType $field)
#if ($field.type.isBasic())
#if ($field.type.hasArray() && !$field.type.isString())
${field.type.typeName}[]##
#else
${field.type.typeName}##
#end
#elseif ($field.type.isString())
${field.type.typeName}##
#else
#if ($field.type.hasArray())
#if ($field.type.isFixedLength())
${field.type.typeName}[]##
#else
java.util.List<${field.type.typeName}>##
#end
#else
${field.type.typeName}##
#end
#end
#end
##
## 宏: 生成属性定义
#macro (declareField $field)
#if ($field.haveComments())
#foreach ($line in $field.comments)
    // $line
#end
#end
    private #declareType($field) ${field.name};
#end
##
## 宏: 生成field的缺省值
#macro (defaultValue $field)
#if ($field.defaultValue)
($field.type.typeName) ${field.defaultValue.value}##
#elseif ($field.type.isString())
null##
#else
${defaultValueMap[${field.type.typeName}]}##
#end
#end
## 宏: 为field赋初值
#macro (initField $field)
#if ($field.type.isBasic())
#if ($field.type.hasArray())
        this.${field.name} = new ${field.type.typeName}[${field.type.arraySize}];
        java.util.Arrays.fill(this.${field.name}, ${defaultValueMap[${field.type.typeName}]});
#else
        this.$field.name = #defaultValue($field);
#end
#elseif ($field.type.isString())
        this.$field.name = #defaultValue($field);
#else
#if ($field.type.hasArray())
#if ($field.type.isFixedLength())
        this.${field.name} = new ${field.type.typeName}[${field.type.arraySize}];
        for (int i = 0; i < ${field.type.arraySize}; ++i) {
            this.${field.name}[i] = new ${field.type.typeName}();
        }
#else
        this.${field.name} = new java.util.LinkedList<${field.type.typeName}>();
#end
#else
        this.${field.name} = new ${field.type.typeName}();
#end
#end
#end
##
/**
 * struct ${structName}
#if ($struct.haveComments())
 *
#foreach ($line in $struct.comments)
 * ${line}
#end
#end
 */
public class ${struct.className} extends Struct {
#foreach ($field in $struct.fields)
#declareField($field)

#end
    public ${struct.className}() {
#foreach ($field in $struct.fields)
#initField($field)

#end
    }

#foreach ($field in $struct.fields)
    public #declareType($field) ${utils.getGetter($field.name)}() {
        return this.${field.name};
    }

#if ((!$field.type.hasArray() && $field.type.isBasic()) || $field.type.isString() || $field.type.isStruct())
    public void ${utils.getSetter($field.name)}(#declareType($field) $field.name) {
        this.${field.name} = ${field.name};
    }

#end
#end
    @Override
    public int calcSize() {
        int __size = 0;

#foreach ($field in $struct.fields)
#if ($field.type.isBasic())
        __size += ${typeSizeMap[${field.type.typeName}]} * ${field.type.arraySize};
#elseif ($field.type.isString())
        __size += ${field.type.arraySize};
#else
#if ($field.type.hasArray())
#if ($field.type.isFixedLength())
        for (int i = 0; i < ${field.type.arraySize}; ++i) {
            __size += this.${field.name}[i].calcSize();
        }
#else
#if ($field.type.arraySize != "")
        this.${field.type.arraySize} = (#declareType($struct.getField($field.type.arraySize))) this.${field.name}.size();
#end
        for (Struct __struct : this.${field.name}) {
            __size += __struct.calcSize();
        }
#end
#else
        __size += this.${field.name}.calcSize();
#end
#end

#end
        return __size;
    }

    @Override
    public void encode(OutputStream output) throws IOException {
#foreach ($field in $struct.fields)
#if ($field.type.isBasic())
#if ($field.type.hasArray())
        for (int i = 0; i < ${field.type.arraySize}; ++i) {
            write(output, this.${field.name}[i], ${field.type.typeName}.class);
        }
#else
        write(output, this.${field.name}, ${field.type.typeName}.class);
#end
#elseif ($field.type.isString())
        writeString(this.${field.name}, ${field.type.arraySize}, output);
#else
#if ($field.type.hasArray())
#if ($field.type.isFixedLength())
        for (int i = 0; i < ${field.type.arraySize}; ++i) {
            this.${field.name}[i].encode(output);
        }
#else
#if ($field.type.arraySize != "")
        this.${field.type.arraySize} = (#declareType($struct.getField($field.type.arraySize))) this.${field.name}.size();
#end
        for (Struct __struct : this.${field.name}) {
            __struct.encode(output);
        }
#end
#else
        if (this.${field.name} != null) {
            this.${field.name}.encode(output);
        }
#end
#end

#end
    }

    @Override
    public Struct decode(InputStream input) throws IOException {
#foreach ($field in $struct.fields)
#if ($field.type.isBasic())
#if ($field.type.hasArray())
        for (int i = 0; i < ${field.type.arraySize}; ++i) {
            this.${field.name}[i] = read(input, ${field.type.typeName}.class);
        }
#else
        this.${field.name} = read(input, ${field.type.typeName}.class);
#end
#elseif ($field.type.isString())
        this.${field.name} = readString(input, ${field.type.arraySize});
#else
#if ($field.type.hasArray())
#if ($field.type.isFixedLength())
        for (int i = 0; i < ${field.type.arraySize}; ++i) {
            this.${field.name}[i].decode(input);
        }
#else
#if ($field.type.arraySize != "")
        for (int i = 0; i < this.${field.type.arraySize}; ++i) {
            this.${field.name}.add(($field.type.typeName) new ${field.type.typeName}().decode(input));
        }
#else
        if (true) {
            throw new UnsupportedOperationException(
                "struct doesn't support decode list which elements number is unknown.");
        }
#end
#end
#else
        this.${field.name}.decode(input);
#end
#end

#end
        return this;
    }
}