/******************************************************************************
 * Struct.java
 * GENERATED BY StructCompiler, DON'T MODIFY MANULLY.
 * Generated Time: ${createTime}
 */
package ${package};

import java.io.*;
import java.util.Arrays;

public class Struct {
    public final static int LITTLE_ENDIAN = 0;
    public final static int BIG_ENDIAN = 1;
    public static int byteOrder = LITTLE_ENDIAN;

    private final static int TRUE = 1;
    private final static int FALSE = 0;

    public void encode(OutputStream output) throws IOException {
    }

    public Struct decode(InputStream input) throws IOException {
        return this;
    }

    public int calcSize() {
        return 0;
    }

    @SuppressWarnings("unchecked")
    public <T> T read(InputStream input, Class<T> clazz) throws IOException {
        DataInputStream dis = new DataInputStream(input);
        if (clazz.equals(Character.class) || clazz.equals(char.class)) {
            return (T) (Character) readChar(dis);
        } else if (clazz.equals(Byte.class) || clazz.equals(byte.class)) {
            return (T) (Byte) readByte(dis);
        } else if (clazz.equals(Boolean.class) || clazz.equals(boolean.class)) {
            return (T) (Boolean) readBoolean(dis);
        } else if (clazz.equals(Short.class) || clazz.equals(short.class)) {
            return (T) (Short) readShort(dis);
        } else if (clazz.equals(Integer.class) || clazz.equals(int.class)) {
            return (T) (Integer) readInteger(dis);
        } else if (clazz.equals(Long.class) || clazz.equals(long.class)) {
            return (T) (Long) readLong(dis);
        } else if (clazz.equals(Float.class) || clazz.equals(float.class)) {
            return (T) (Float) readFloat(dis);
        } else if (clazz.equals(Double.class) || clazz.equals(double.class)) {
            return (T) (Double) readDouble(dis);
        } else {
            throw new UnsupportedOperationException("unsupported read operation on class " + clazz.getName());
        }
    }

    public void write(OutputStream output, Object obj, Class<?> clazz) throws IOException {
        DataOutputStream dos = new DataOutputStream(output);
        if (clazz.equals(Character.class) || clazz.equals(char.class)) {
            writeChar((Character) obj, dos);
        } else if (clazz.equals(Byte.class) || clazz.equals(byte.class)) {
            writeByte((Byte) obj, dos);
        } else if (clazz.equals(Boolean.class) || clazz.equals(boolean.class)) {
            writeBoolean((Boolean) obj, dos);
        } else if (clazz.equals(Short.class) || clazz.equals(short.class)) {
            writeShort((Short) obj, dos);
        } else if (clazz.equals(Integer.class) || clazz.equals(int.class)) {
            writeInteger((Integer) obj, dos);
        } else if (clazz.equals(Long.class) || clazz.equals(long.class)) {
            writeLong((Long) obj, dos);
        } else if (clazz.equals(Float.class) || clazz.equals(float.class)) {
            writeFloat((Float) obj, dos);
        } else if (clazz.equals(Double.class) || clazz.equals(double.class)) {
            writeDouble((Double) obj, dos);
        } else {
            throw new UnsupportedOperationException("unsupported write operation on class " + clazz.getName());
        }
    }

    public String readString(InputStream input, int len) throws IOException {
        DataInputStream dis = new DataInputStream(input);
        byte[] bytes = new byte[len];
        dis.readFully(bytes);
        return getString(bytes);
    }

    public void writeString(String value, int len, OutputStream output) throws IOException {
        DataOutputStream dos = new DataOutputStream(output);
        int strlen = isEmpty(value) ? 0 : value.length();
        int wlen = strlen < len ? strlen : len;
        int diff = len - wlen;

        if (wlen > 0) {
            byte[] bytes = value.getBytes();
            dos.write(bytes, 0, wlen);
        }

        if (diff > 0) {
            byte[] buf = new byte[64];
            Arrays.fill(buf, (byte) 0);
            int cnt = diff / buf.length;
            int mod = diff % buf.length;
            for (int i = 0; i < cnt; ++i) {
                dos.write(buf);
            }
            if (mod > 0) {
                dos.write(buf, 0, mod);
            }
        }
    }

    public byte readByte(DataInput dis) throws IOException {
        return dis.readByte();
    }

    public void writeByte(byte value, DataOutput dos) throws IOException {
        dos.writeByte(value);
    }

    public char readChar(DataInput dis) throws IOException {
        return dis.readChar();
    }

    public void writeChar(char value, DataOutput dos) throws IOException {
        dos.writeChar(value);
    }

    public boolean readBoolean(DataInput dis) throws IOException {
        return dis.readByte() == TRUE;
    }

    public void writeBoolean(boolean value, DataOutput dos) throws IOException {
        dos.writeByte(value ? TRUE : FALSE);
    }

    public short readShort(DataInput dis) throws IOException {
        short bits = dis.readShort();
        return byteOrder == LITTLE_ENDIAN ? Short.reverseBytes(bits) : bits;
    }

    public void writeShort(short value, DataOutput dos) throws IOException {
        short bits = byteOrder == LITTLE_ENDIAN ? Short.reverseBytes(value) : value;
        dos.writeShort(bits);
    }

    public int readInteger(DataInput dis) throws IOException {
        int bits = dis.readInt();
        return byteOrder == LITTLE_ENDIAN ? Integer.reverseBytes(bits) : bits;
    }

    public void writeInteger(int value, DataOutput dos) throws IOException {
        int bits = byteOrder == LITTLE_ENDIAN ? Integer.reverseBytes(value) : value;
        dos.writeInt(bits);
    }

    public long readLong(DataInput dis) throws IOException {
        long bits = dis.readLong();
        return byteOrder == LITTLE_ENDIAN ? Long.reverseBytes(bits) : bits;
    }

    public void writeLong(long value, DataOutput dos) throws IOException {
        long bits = byteOrder == LITTLE_ENDIAN ? Long.reverseBytes(value) : value;
        dos.writeLong(bits);
    }

    public float readFloat(DataInput dis) throws IOException {
        float bits = dis.readFloat();
        return byteOrder == LITTLE_ENDIAN ?
                Float.intBitsToFloat(Integer.reverseBytes(Float.floatToIntBits(bits))) :
                bits;
    }

    public void writeFloat(float value, DataOutput dos) throws IOException {
        float bits = byteOrder == LITTLE_ENDIAN ?
                Float.intBitsToFloat(Integer.reverseBytes(Float.floatToIntBits(value))) :
                value;
        dos.writeFloat(bits);

    }

    public double readDouble(DataInput dis) throws IOException {
        double bits = dis.readDouble();
        return byteOrder == LITTLE_ENDIAN ?
                Double.longBitsToDouble(Long.reverseBytes(Double.doubleToLongBits(bits))) :
                bits;
    }

    public void writeDouble(double value, DataOutput dos) throws IOException {
        double bits = byteOrder == LITTLE_ENDIAN ?
                Double.longBitsToDouble(Long.reverseBytes(Double.doubleToLongBits(value))) :
                value;
        dos.writeDouble(bits);
    }

    public int readBits(BitInputStream bis, int num) throws IOException {
        int value = 0;
        for (int i = 0; i < num; ++i) {
            if (i > 0) {
                value <<= 1;
            }
            if (bis.read() != 0) {
                value |= 0x01;
            }
        }
        return value;
    }

    public void writeBits(int value, int num, BitOutputStream bos) throws IOException {
        for (long mask = 1L << (num - 1); mask > 0; mask >>= 1) {
            bos.write((int) (mask & value));
        }
    }

    private boolean isEmpty(String str) {
        if (str == null) {
            return true;
        } else {
            return str.length() == 0;
        }
    }

    private String getString(byte[] bytes) {
        int i;
        for (i = 0; i < bytes.length; ++i) {
            if (bytes[i] == 0) {
                break;
            }
        }
        return new String(bytes, 0, i);
    }

    public class BitInputStream extends InputStream {
        private InputStream input;
        private int value;
        private int index;

        public BitInputStream(InputStream input) {
            this.input = input;
            this.value = 0;
            this.index = -1;
        }

        @Override
        public int read() throws IOException {
            if (index < 0) {
                if ((value = input.read()) == -1) {
                    throw new IOException("unexpected EOF");
                }
                index = 7;
            }

            return (value & (0x01 << index--)) != 0 ? 1 : 0;
        }

        @Override
        public void close() throws IOException {
            input.close();
        }
    }

    public class BitOutputStream extends OutputStream {
        private int value;
        private int num;
        private OutputStream ostream;

        public BitOutputStream(OutputStream ostream) {
            this.value = 0;
            this.num = 0;
            this.ostream = ostream;
        }

        @Override
        public void write(int b) throws IOException {
            int mask = b == 0 ? 0 : 1;
            value = (value << 1) | mask;
            ++num;
            if (num == 8) {
                ostream.write(value);
                value = 0;
                num = 0;
            }
        }

        public void end() throws IOException {
            if (num > 0) {
                value <<= 8 - num;
                ostream.write(value);
                num = 0;
                value = 0;
            }
        }

        @Override
        public void flush() throws IOException {
            ostream.flush();
        }

        @Override
        public void close() throws IOException {
            end();
            ostream.close();
        }
    }
}
